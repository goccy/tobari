# Tobari

[![PkgGoDev](https://pkg.go.dev/badge/github.com/goccy/tobari)](https://pkg.go.dev/github.com/goccy/tobari)
![Go](https://github.com/goccy/tobari/workflows/Go/badge.svg)


"Tobari" was named after the Japanese word 「帷」, which carries the meaning of "cover" in English.

Tobari is a coverage measurement tool based on goroutine IDs. With finer-grained control that is not possible with runtime/coverage, it allows you to selectively measure only the code you truly want to track.

# Motivation

With the `runtime/coverage` package, it has become possible to dynamically measure coverage in running applications. However, when actually attempting to measure coverage for HTTP or gRPC servers, several issues have been identified.

For example, suppose you want to run test cases against a running HTTP server and measure the coverage generated by those test cases.

The runtime/coverage package records all executed paths between the start and end of measurement. As a result, paths not executed by the test cases may also be included in the coverage. For example, in the following situations:

- When asynchronous processes using goroutines continue to run
- When requests unrelated to coverage measurement are sent to the running HTTP server

To address this, I came up with a method to measure coverage based on Goroutine IDs. By using this approach, it becomes possible to selectively measure only the requests you intend to track. Any unrelated asynchronous processes running during measurement, as well as unrelated requests, will not be included in the coverage.

# Installation

```
go install github.com/goccy/tobari/cmd/tobari@latest
```

# Usage

Tobari works by adding a dedicated flag during the Go build process. When running the usual `go build` or `go run` commands, please specify the `GOFLAGS` environment variable as shown below.

```
GOFLAGS="$(tobari flags)" go run ./examples/http/main.go
```

`tobari flags` return execution results as shown below.

```
-cover -overlay=/var/folders/6g/zp4b7mqx7kg5mpdjjk98hz5w0000gp/T/tobari/go1.25.1/overlay.json -toolexec=/path/to/bin/tobari
```

Next, just like when using the `runtime/coverage` package, make modifications to the code you want to measure.
Tobari currently provides only three simple APIs:

- `ClearCounters`: starts of coverage measurement
- `Cover`: wraps the code to be measured
- `WriteCoverProfile`: writes out the results at the end of measurement.

Below is a minimal example using these APIs.

```go
package main

import (
  "github.com/goccy/tobari"
)

func main() {
    tobari.ClearCounters()
    tobari.Cover(func() { fmt.Println("hello tobari") })
    tobari.WriteCoverProfile(tobari.SetMode, os.Stdout)
}
```

# Example

We will use a more practical example to give you a better idea of how to use tobari. The example code is located in examples/http, so you can run it on your own environment as well.

First, install the tobari CLI using the following command.

```
go install github.com/goccy/tobari/cmd/tobari@latest
```

Next, to run the example, clone the repository and navigate to the repository root.

```
git clone https://github.com/goccy/tobari.git
cd tobari
```

The examples/http directory contains code structured as follows.

```go
package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/httptest"
	"os"

	"github.com/goccy/tobari"
)

func coverageMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if v := r.Header.Get("X-GO-COVERAGE"); v != "" {
			// When measuring coverage, wrap the function with tobari.Cover.
			tobari.Cover(func() { next.ServeHTTP(w, r) })
		} else {
			next.ServeHTTP(w, r)
		}
	})
}

var ch = make(chan struct{})

func run(ctx context.Context) error {
	mux := http.NewServeMux()

	// This is the endpoint used to start measuring coverage.
	mux.HandleFunc("/coverstart", func(w http.ResponseWriter, req *http.Request) {
		// Similar to ClearCounters in runtime/coverage, this resets the currently active counters.
		// It is intended to be called at the start of coverage measurement.
		tobari.ClearCounters()

		// This process is used to ensure that goroutines not subject to measurement are correctly ignored.
		// Normally, when coverage measurement begins, all goroutines are included in the measurement.
		// However, in Tobari, it is possible to count only specific processes, so the coverage of this goroutine will be ignored.
		go func() {
			<-ch
		}()

		fmt.Fprintf(w, "started")
	})

	// This is the endpoint used to stop coverage measurement and retrieve the results.
	mux.HandleFunc("/coverend", func(w http.ResponseWriter, req *http.Request) {
		// Writes data in coverprofile format.
		// The resulting output can be directly used with `go tool cover`.
		tobari.WriteCoverProfile(tobari.SetMode, w)
	})

	mux.HandleFunc("/foo", func(w http.ResponseWriter, req *http.Request) {
		fmt.Fprintf(w, "foo")
	})
	mux.HandleFunc("/bar", func(w http.ResponseWriter, req *http.Request) {
		fmt.Fprintf(w, "bar")
	})

	// A middleware is added to switch behavior based on the presence of the coverage flag.
	srv := httptest.NewServer(coverageMiddleware(mux))
	defer srv.Close()

	cli := new(http.Client)

	// start coverage.
	if err := func() error {
		req, err := http.NewRequest("GET", srv.URL+"/coverstart", nil)
		if err != nil {
			return err
		}
		resp, err := cli.Do(req)
		if err != nil {
			return err
		}
		defer resp.Body.Close()
		b, err := io.ReadAll(resp.Body)
		if err != nil {
			return err
		}
		fmt.Println(string(b))
		return nil
	}(); err != nil {
		return err
	}

	// access foo endpoint with X-GO-COVERAGE header.
	if err := func() error {
		req, err := http.NewRequest("GET", srv.URL+"/foo", nil)
		if err != nil {
			return err
		}
		req.Header.Add("X-GO-COVERAGE", "true")
		resp, err := cli.Do(req)
		if err != nil {
			return err
		}
		defer resp.Body.Close()
		b, err := io.ReadAll(resp.Body)
		if err != nil {
			return err
		}
		fmt.Println(string(b))
		return nil
	}(); err != nil {
		return err
	}

	// access bar endpoint without coverage header.
	if err := func() error {
		req, err := http.NewRequest("GET", srv.URL+"/bar", nil)
		if err != nil {
			return err
		}
		resp, err := cli.Do(req)
		if err != nil {
			return err
		}
		defer resp.Body.Close()
		b, err := io.ReadAll(resp.Body)
		if err != nil {
			return err
		}
		fmt.Println(string(b))
		return nil
	}(); err != nil {
		return err
	}

	// end coverage.
	if err := func() error {
		req, err := http.NewRequest("GET", srv.URL+"/coverend", nil)
		if err != nil {
			return err
		}
		resp, err := cli.Do(req)
		if err != nil {
			return err
		}
		defer resp.Body.Close()
		b, err := io.ReadAll(resp.Body)
		if err != nil {
			return err
		}
		return os.WriteFile("test.cover", b, 0o600)
	}(); err != nil {
		return err
	}
	return nil
}

func main() {
	if err := run(context.Background()); err != nil {
		log.Fatal(err)
	}
}
```

Run this code using the following command.

```
GOFLAGS="$(/path/to/tobari flags)" go run ./examples/http/main.go
```

Then, a `test.cover` file should be created in the current directory. Let’s view it using `go tool cover -html`.

```
go tool cover -html test.cover
```

This will produce an output like the following. What’s notable is that even though both foo and bar are accessed after coverage measurement starts, only foo is actually measured.

<img width="791" height="771" alt="image" src="https://github.com/user-attachments/assets/d89a3c38-8ce9-4867-a4a0-d6b7fe96ad3c" />

# How it works

Tobari works by specifying three options as build options via the `tobari flags` command. Each is used for the following purposes:

- `-cover`: Used to embed coverage measurement points. While this is usually handled by the `go tool cover`, Tobari replaces it (via `toolexec`, described below) to insert coverage points in a way that enables goroutine ID based measurement — something the standard tool cannot do.

- `-overlay`: Dynamically adds `GID` and `PGID` functions to the runtime package to retrieve goroutine IDs. `GID` returns the current goroutine's ID, while `PGID` returns the parent goroutine's ID. By measuring these, Tobari can track goroutine dependencies.

- `-toolexec`: Used to replace the `go tool cover` command with Tobari, enabling it to inject its own coverage logic during the build process.

You specify the function to be measured in `tobari.Cover()`. By invoking that function through a newly started goroutine, you obtain the root goroutine ID. After the measurement is complete, Tobari traces the child goroutines created from that root, allowing it to identify and isolate only the relevant code paths.

# License

MIT
