# Tobari

"Tobari" was named after the Japanese word 「帷」, which carries the meaning of "cover" in English.

Tobari is a coverage measurement tool based on goroutine IDs. With finer-grained control that is not possible with runtime/coverage, it allows you to selectively measure only the code you truly want to track.

# Motivation

With the `runtime/coverage` package, it has become possible to dynamically measure coverage in running applications. However, when actually attempting to measure coverage for HTTP or gRPC servers, several issues have been identified.

For example, suppose you want to run test cases against a running HTTP server and measure the coverage generated by those test cases.

The runtime/coverage package records all executed paths between the start and end of measurement. As a result, paths not executed by the test cases may also be included in the coverage. For example, in the following situations:

- When asynchronous processes using goroutines continue to run
- When requests unrelated to coverage measurement are sent to the running HTTP server

To address this, I came up with a method to measure coverage based on Goroutine IDs. By using this approach, it becomes possible to selectively measure only the requests you intend to track. Any unrelated asynchronous processes running during measurement, as well as unrelated requests, will not be included in the coverage.

# Installation

```
go install github.com/goccy/tobari/cmd/tobari@latest
```

# Usage

Tobari works by adding a dedicated flag during the Go build process. When running the usual `go build` or `go run` commands, please specify the `GOFLAGS` environment variable as shown below.

```
GOFLAGS="$(tobari flags)" go run ./examples/http/main.go
```

`tobari flags` return execution results as shown below.

```
-cover -overlay=/var/folders/6g/zp4b7mqx7kg5mpdjjk98hz5w0000gp/T/tobari/go1.25.1/overlay.json -toolexec=/path/to/bin/tobari
```

Next, just like when using the `runtime/coverage` package, make modifications to the code you want to measure.
Tobari currently provides only three simple APIs:

- `ClearCounters`: starts of coverage measurement
- `Cover`: wraps the code to be measured
- `WriteCoverProfile`: writes out the results at the end of measurement.

Below is a minimal example using these APIs.

```go
package main

import (
  "github.com/goccy/tobari"
)

func main() {
    tobari.ClearCounters()
    tobari.Cover(func() { fmt.Println("hello tobari") })
    tobari.WriteCoverProfile(tobari.SetMode, os.Stdout)
}
```

If you want to see a more practical example, please refer to the sample located in [examples/http](./examples/http/main.go).


# How it works

Tobari works by specifying three options as build options via the `tobari flags` command. Each is used for the following purposes:

- `-cover`: Used to embed coverage measurement points. While this is usually handled by the `go tool cover`, Tobari replaces it (via `toolexec`, described below) to insert coverage points in a way that enables goroutine ID based measurement — something the standard tool cannot do.

- `-overlay`: Dynamically adds `GID` and `PGID` functions to the runtime package to retrieve goroutine IDs. `GID` returns the current goroutine's ID, while `PGID` returns the parent goroutine's ID. By measuring these, Tobari can track goroutine dependencies.

- `-toolexec`: Used to replace the `go tool cover` command with Tobari, enabling it to inject its own coverage logic during the build process.

You specify the function to be measured in `tobari.Cover()`. By invoking that function through a newly started goroutine, you obtain the root goroutine ID. After the measurement is complete, Tobari traces the child goroutines created from that root, allowing it to identify and isolate only the relevant code paths.

# License

MIT