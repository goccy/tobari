// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package cover implements coverage instrumentation functionality.
// Some code in this file is derived from Go's coverage tool.
package cover

import (
	"bytes"
	"context"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

func Run(ctx context.Context, args []string) error {
	inputFiles, opt, err := parseOption(args)
	if err != nil {
		return err
	}
	if len(inputFiles) == 0 {
		return nil
	}

	if len(inputFiles) == 1 && opt.output != "" {
		if err := annotateFile(inputFiles[0], opt.output, opt.mode); err != nil {
			return err
		}
		if opt.outputFileList != "" {
			return writeOutputFileList(opt.outputFileList, []string{opt.output})
		}
		if err := createCovervars(opt.pkgcfg); err != nil {
			return nil
		}
		return nil
	}

	outputFiles := make([]string, 0, len(inputFiles))
	for _, inputFile := range inputFiles {
		base := filepath.Base(inputFile)
		if filepath.Ext(base) == ".go" {
			base = base[:len(base)-len(filepath.Ext(base))]
		}
		outputName := base + ".cover.go"
		if err := annotateFile(inputFile, outputName, opt.mode); err != nil {
			return err
		}
		outputFiles = append(outputFiles, outputName)
	}
	if err := writeOutputFileList(opt.outputFileList, outputFiles); err != nil {
		return nil
	}
	if err := createCovervars(opt.pkgcfg); err != nil {
		return nil
	}
	return nil
}

func createCovervars(pkgcfg string) error {
	if pkgcfg != "" {
		covervarsPath := strings.Replace(pkgcfg, "pkgcfg.txt", "covervars.go", 1)
		src := `
package main

// Coverage variables placeholder
// Generated by tobari
`
		if err := os.WriteFile(covervarsPath, []byte(src), 0o600); err != nil {
			return err
		}
	}
	return nil
}

type Option struct {
	mode           string
	output         string
	outputFileList string
	pkgcfg         string
}

func parseOption(args []string) ([]string, *Option, error) {
	fs := flag.NewFlagSet("cover", flag.ContinueOnError)
	mode := fs.String("mode", "count", "coverage mode: count, atomic")
	output := fs.String("o", "", "output file")
	outfilelist := fs.String("outfilelist", "", "file containing list of output files")
	pkgcfg := fs.String("pkgcfg", "", "package configuration file")
	_ = fs.String("var", "", "name of coverage variable prefix")
	_ = fs.String("V", "", "version flag")

	if err := fs.Parse(args); err != nil {
		return nil, nil, err
	}
	return fs.Args(), &Option{
		mode:           *mode,
		output:         *output,
		outputFileList: *outfilelist,
		pkgcfg:         *pkgcfg,
	}, nil
}

func writeOutputFileList(filename string, outputFiles []string) (e error) {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer func() {
		e = file.Close()
	}()

	for _, outFile := range outputFiles {
		if _, err := fmt.Fprintf(file, "%s\n", outFile); err != nil {
			return err
		}
	}
	return nil
}

func annotateFile(src, dst, mode string) error {
	if dst != "" {
		return CreateFile(src, dst, mode)
	}
	b, err := AddTracePoint(src, mode)
	if err != nil {
		return err
	}
	if _, err := os.Stdout.Write(b); err != nil {
		return err
	}
	return nil
}

func CreateFile(src, dst, mode string) error {
	converted, err := AddTracePoint(src, mode)
	if err != nil {
		return err
	}
	if err := os.WriteFile(dst, converted, 0o600); err != nil {
		return err
	}
	return nil
}

func AddTracePoint(src, mode string) ([]byte, error) {
	f, err := os.ReadFile(src)
	if err != nil {
		return nil, err
	}
	return AddTracePointWithContent(src, f, mode)
}

type Block struct {
	startByte token.Pos
	endByte   token.Pos
	numStmt   int
}

type File struct {
	fset    *token.FileSet
	name    string
	mode    string
	astFile *ast.File
	blocks  []Block
	content []byte
	edit    *Buffer
}

func AddTracePointWithContent(filename string, content []byte, mode string) ([]byte, error) {
	fset := token.NewFileSet()
	parsedFile, err := parser.ParseFile(fset, filename, content, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	file := &File{
		fset:    fset,
		mode:    mode,
		name:    filename,
		content: content,
		edit:    NewBuffer(content),
		astFile: parsedFile,
	}

	// Add import of github.com/goccy/tobari
	file.addImport()

	// Walk the AST and instrument code
	ast.Walk(file, file.astFile)

	return append(file.edit.Bytes(), []byte(`
var _ = github_com_goccy_tobari.SetGIDFunc(func() uint64 {
  return github_com_goccy_tobari_runtime.GID()
})
`)...), nil
}

func (f *File) addImport() {
	// Add import after package declaration
	importStmt := `
import github_com_goccy_tobari_runtime "runtime"
import github_com_goccy_tobari "github.com/goccy/tobari"
`

	f.edit.Insert(f.offset(f.astFile.Name.End()), importStmt)
}

func (f *File) offset(pos token.Pos) int {
	return f.fset.Position(pos).Offset
}

func (f *File) Visit(node ast.Node) ast.Visitor {
	switch n := node.(type) {
	case *ast.BlockStmt:
		// Handle block statements like the original cover tool
		if len(n.List) > 0 {
			switch n.List[0].(type) {
			case *ast.CaseClause: // switch
				for _, stmt := range n.List {
					clause := stmt.(*ast.CaseClause)
					f.addCounters(clause.Colon+1, clause.Colon+1, clause.End(), clause.Body, false)
				}
				return f
			case *ast.CommClause: // select
				for _, stmt := range n.List {
					clause := stmt.(*ast.CommClause)
					f.addCounters(clause.Colon+1, clause.Colon+1, clause.End(), clause.Body, false)
				}
				return f
			}
		}
		f.addCounters(n.Lbrace, n.Lbrace+1, n.Rbrace+1, n.List, true)
	case *ast.IfStmt:
		if n.Init != nil {
			ast.Walk(f, n.Init)
		}
		ast.Walk(f, n.Cond)
		ast.Walk(f, n.Body)
		if n.Else == nil {
			return nil
		}
		// The elses are special, because if we have
		//	if x {
		//	} else if y {
		//	}
		// we want to cover the "if y". To do this, we need a place to drop the counter,
		// so we add a hidden block:
		//	if x {
		//	} else {
		//		if y {
		//		}
		//	}
		elseOffset := f.findText(n.Body.End(), "else")
		if elseOffset < 0 {
			panic("lost else")
		}
		f.edit.Insert(elseOffset+4, "{")
		f.edit.Insert(f.offset(n.Else.End()), "}")

		// We just created a block, now walk it.
		// Adjust the position of the new block to start after
		// the "else". That will cause it to follow the "{"
		// we inserted above.
		pos := f.fset.File(n.Body.End()).Pos(elseOffset + 4)
		switch stmt := n.Else.(type) {
		case *ast.IfStmt:
			block := &ast.BlockStmt{
				Lbrace: pos,
				List:   []ast.Stmt{stmt},
				Rbrace: stmt.End(),
			}
			n.Else = block
		case *ast.BlockStmt:
			stmt.Lbrace = pos
		default:
			panic("unexpected node type in if")
		}
		ast.Walk(f, n.Else)
		return nil
	case *ast.SelectStmt:
		// Don't annotate an empty select - creates a syntax error.
		if n.Body == nil || len(n.Body.List) == 0 {
			return nil
		}
	case *ast.SwitchStmt:
		// Don't annotate an empty switch - creates a syntax error.
		if n.Body == nil || len(n.Body.List) == 0 {
			if n.Init != nil {
				ast.Walk(f, n.Init)
			}
			if n.Tag != nil {
				ast.Walk(f, n.Tag)
			}
			return nil
		}
	case *ast.TypeSwitchStmt:
		// Don't annotate an empty type switch - creates a syntax error.
		if n.Body == nil || len(n.Body.List) == 0 {
			if n.Init != nil {
				ast.Walk(f, n.Init)
			}
			ast.Walk(f, n.Assign)
			return nil
		}
	case *ast.FuncDecl:
		// Don't instrument functions with blank names or bodyless functions
		if n.Name.Name == "_" || n.Body == nil {
			return nil
		}
		// Determine proper function or method name.
		fname := n.Name.Name
		if r := n.Recv; r != nil && len(r.List) == 1 {
			t := r.List[0].Type
			star := ""
			if p, _ := t.(*ast.StarExpr); p != nil {
				t = p.X
				star = "*"
			}
			if p, _ := t.(*ast.Ident); p != nil {
				fname = star + p.Name + "." + fname
			}
		}
		_ = fname
		ast.Walk(f, n.Body)
		return nil
	case *ast.FuncLit:
		ast.Walk(f, n.Body)
		return nil
	}
	return f
}

// findText finds text in the original source, starting at pos.
// It correctly skips over comments and assumes it need not
// handle quoted strings.
// It returns a byte offset within f.src.
func (f *File) findText(pos token.Pos, text string) int {
	b := []byte(text)
	start := f.offset(pos)
	i := start
	s := f.content
	for i < len(s) {
		if bytes.HasPrefix(s[i:], b) {
			return i
		}
		if i+2 <= len(s) && s[i] == '/' && s[i+1] == '/' {
			for i < len(s) && s[i] != '\n' {
				i++
			}
			continue
		}
		if i+2 <= len(s) && s[i] == '/' && s[i+1] == '*' {
			for i += 2; ; i++ {
				if i+2 > len(s) {
					return 0
				}
				if s[i] == '*' && s[i+1] == '/' {
					i += 2
					break
				}
			}
			continue
		}
		i++
	}
	return -1
}

// addCounters takes a list of statements and adds counters to the beginning of
// each basic block at the top level of that list. For instance, given
//
//	S1
//	if cond {
//		S2
//	}
//	S3
//
// counters will be added before S1 and before S3. The block containing S2
// will be visited in a separate call.
// TODO: Nested simple blocks get unnecessary (but correct) counters
func (f *File) addCounters(pos, insertPos, blockEnd token.Pos, list []ast.Stmt, extendToClosingBrace bool) {
	// Special case: make sure we add a counter to an empty block. Can't do this below
	// or we will add a counter to an empty statement list after, say, a return statement.
	if len(list) == 0 {
		f.edit.Insert(f.offset(insertPos), f.newCounter(insertPos, blockEnd, 0)+";")
		return
	}
	// Make a copy of the list, as we may mutate it and should leave the
	// existing list intact.
	list = append([]ast.Stmt(nil), list...)
	// We have a block (statement list), but it may have several basic blocks due to the
	// appearance of statements that affect the flow of control.
	for {
		// Find first statement that affects flow of control (break, continue, if, etc.).
		// It will be the last statement of this basic block.
		var last int
		end := blockEnd
		for last = 0; last < len(list); last++ {
			stmt := list[last]
			end = f.statementBoundary(stmt)
			if f.endsBasicSourceBlock(stmt) {
				if label, isLabel := stmt.(*ast.LabeledStmt); isLabel && !f.isControl(label.Stmt) {
					newLabel := *label
					newLabel.Stmt = &ast.EmptyStmt{
						Semicolon: label.Stmt.Pos(),
						Implicit:  true,
					}
					end = label.Pos() // Previous block ends before the label.
					list[last] = &newLabel
					// Open a gap and drop in the old statement, now without a label.
					list = append(list, nil)
					copy(list[last+1:], list[last:])
					list[last+1] = label.Stmt
				}
				last++
				extendToClosingBrace = false // Block is broken up now.
				break
			}
		}
		if extendToClosingBrace {
			end = blockEnd
		}
		if pos != end { // Can have no source to cover if e.g. blocks abut.
			f.edit.Insert(f.offset(insertPos), f.newCounter(pos, end, last)+";")
		}
		list = list[last:]
		if len(list) == 0 {
			break
		}
		pos = list[0].Pos()
		insertPos = pos
	}
}

// newCounter creates a new counter expression of the appropriate form.
func (f *File) newCounter(start, end token.Pos, numStmt int) string {
	stpos := f.fset.Position(start)
	enpos := f.fset.Position(end)

	// blockIndex (using the current block count as index)
	blockIndex := len(f.blocks)

	// Generate both standard coverage call and our custom call
	// This ensures compatibility with Go's coverage runtime while adding our functionality.
	stmt := fmt.Sprintf(
		"github_com_goccy_tobari.Trace(%q, %q, github_com_goccy_tobari_runtime.PGID(), github_com_goccy_tobari_runtime.GID(), %d, %d, %d, %d, %d, %d)",
		f.name, f.mode,
		blockIndex,
		stpos.Line, enpos.Line,
		stpos.Column, enpos.Column,
		numStmt,
	)
	f.blocks = append(f.blocks, Block{start, end, numStmt})
	return stmt
}

// statementBoundary finds the location in s that terminates the current basic
// block in the source.
func (f *File) statementBoundary(s ast.Stmt) token.Pos {
	// Control flow statements are easy.
	switch s := s.(type) {
	case *ast.BlockStmt:
		// Treat blocks like basic blocks to avoid overlapping counters.
		return s.Lbrace
	case *ast.IfStmt:
		if found, pos := hasFuncLiteral(s.Init); found {
			return pos
		}
		if found, pos := hasFuncLiteral(s.Cond); found {
			return pos
		}
		return s.Body.Lbrace
	case *ast.ForStmt:
		if found, pos := hasFuncLiteral(s.Init); found {
			return pos
		}
		if found, pos := hasFuncLiteral(s.Cond); found {
			return pos
		}
		if found, pos := hasFuncLiteral(s.Post); found {
			return pos
		}
		return s.Body.Lbrace
	case *ast.LabeledStmt:
		return f.statementBoundary(s.Stmt)
	case *ast.RangeStmt:
		if found, pos := hasFuncLiteral(s.X); found {
			return pos
		}
		return s.Body.Lbrace
	case *ast.SwitchStmt:
		if found, pos := hasFuncLiteral(s.Init); found {
			return pos
		}
		if found, pos := hasFuncLiteral(s.Tag); found {
			return pos
		}
		return s.Body.Lbrace
	case *ast.SelectStmt:
		return s.Body.Lbrace
	case *ast.TypeSwitchStmt:
		if found, pos := hasFuncLiteral(s.Init); found {
			return pos
		}
		return s.Body.Lbrace
	}

	if found, pos := hasFuncLiteral(s); found {
		return pos
	}
	return s.End()
}

// endsBasicSourceBlock reports whether s changes the flow of control: break, if, etc.,
// or if it's just problematic, for instance contains a function literal, which will complicate
// accounting due to the block-within-an expression.
func (f *File) endsBasicSourceBlock(s ast.Stmt) bool {
	switch s := s.(type) {
	case *ast.BlockStmt:
		// Treat blocks like basic blocks to avoid overlapping counters.
		return true
	case *ast.BranchStmt:
		return true
	case *ast.ForStmt:
		return true
	case *ast.IfStmt:
		return true
	case *ast.LabeledStmt:
		return true // A goto may branch here, starting a new basic block.
	case *ast.RangeStmt:
		return true
	case *ast.SwitchStmt:
		return true
	case *ast.SelectStmt:
		return true
	case *ast.TypeSwitchStmt:
		return true
	case *ast.ExprStmt:
		// Calls to panic change the flow.
		// We really should verify that "panic" is the predefined function,
		// but without type checking we can't and the likelihood of it being
		// an actual problem is vanishingly small.
		if call, ok := s.X.(*ast.CallExpr); ok {
			if ident, ok := call.Fun.(*ast.Ident); ok && ident.Name == "panic" && len(call.Args) == 1 {
				return true
			}
		}
	}
	found, _ := hasFuncLiteral(s)
	return found
}

// isControl reports whether s is a control statement that, if labeled, cannot be
// separated from its label.
func (f *File) isControl(s ast.Stmt) bool {
	switch s.(type) {
	case *ast.ForStmt, *ast.RangeStmt, *ast.SwitchStmt, *ast.SelectStmt, *ast.TypeSwitchStmt:
		return true
	}
	return false
}

// hasFuncLiteral reports the existence and position of the first func literal
// in the node, if any. If a func literal appears, it usually marks the termination
// of a basic block because the function body is itself a block.
// Therefore we draw a line at the start of the body of the first function literal we find.
// TODO: what if there's more than one? Probably doesn't matter much.
func hasFuncLiteral(n ast.Node) (bool, token.Pos) {
	if n == nil {
		return false, 0
	}
	var literal funcLitFinder
	ast.Walk(&literal, n)
	return literal.found(), token.Pos(literal)
}

// funcLitFinder implements the ast.Visitor pattern to find the location of any
// function literal in a subtree.
type funcLitFinder token.Pos

func (f *funcLitFinder) Visit(node ast.Node) ast.Visitor {
	if f.found() {
		return nil // Prune search.
	}
	switch n := node.(type) {
	case *ast.FuncLit:
		*f = funcLitFinder(n.Body.Lbrace)
		return nil // Prune search.
	}
	return f
}

func (f *funcLitFinder) found() bool {
	return token.Pos(*f) != token.NoPos
}

// Buffer represents an edit buffer for making changes to source code
type Buffer struct {
	original []byte
	edits    []edit
}

type edit struct {
	start   int
	end     int
	newText string
}

// NewBuffer creates a new edit buffer
func NewBuffer(data []byte) *Buffer {
	return &Buffer{
		original: data,
		edits:    nil,
	}
}

// Insert adds text at the specified offset
func (b *Buffer) Insert(offset int, text string) {
	b.edits = append(b.edits, edit{
		start:   offset,
		end:     offset,
		newText: text,
	})
}

// Replace replaces text from start to end with newText
func (b *Buffer) Replace(start, end int, newText string) {
	b.edits = append(b.edits, edit{
		start:   start,
		end:     end,
		newText: newText,
	})
}

// Bytes returns the modified content
func (b *Buffer) Bytes() []byte {
	if len(b.edits) == 0 {
		return b.original
	}

	// Sort edits by start position (reverse order for correct application)
	sort.Slice(b.edits, func(i, j int) bool {
		return b.edits[i].start > b.edits[j].start
	})

	result := make([]byte, len(b.original))
	copy(result, b.original)

	// Apply edits from end to beginning to avoid offset shifts
	for _, e := range b.edits {
		// Insert or replace
		before := result[:e.start]
		after := result[e.end:]

		newResult := make([]byte, 0, len(before)+len(e.newText)+len(after))
		newResult = append(newResult, before...)
		newResult = append(newResult, []byte(e.newText)...)
		newResult = append(newResult, after...)

		result = newResult
	}

	return result
}
